<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Gamedev Canvas Workshop</title>
    <style>
        body {
            position: fixed;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
            overflow: hidden;
        }
        h1, p {
            text-align: center;
        }
        #board {
            position: relative;
            width: 480px;
            margin: 0 auto;
            text-align: left;
        }

        #board #level, #board #point {
            position: absolute;
            top: 0;
            font-size: 1.5em;
            font-weight: bold;
        }
        #board #level {
            left: 0;
        }
        #board #point {
            right: 0;
            color: #ff0000;
        }

        canvas {
            display: block;
            margin: 10px auto;
            background: #eee;
        }

        #bar {
            width: 480px;
            margin: 0 auto;
            text-align: center;
        }
    </style>
</head>
<body>
    <h1>벽돌깨기 게임</h1>
    <div id="board">
        <p id="message">게임 시작</p>
        <span id="level"></span>
        <span id="point"></span>
    </div>

    <canvas id="myCanvas" width="480" height="400"></canvas>

    <div id="bar">
        <button id="start" onclick="gameStart();">시작</button>
    </div>
    
    <script>
        const canvas = document.getElementById('myCanvas');
        const ctx = canvas.getContext('2d');
        let gameLevel = 1;
        let gamePoint = 0;
        let gameOn = false;
        let gameHandle;

        const ballRadius = 10;
        const BALL_SPEED = 2 + 0.2 * gameLevel;
        let x = ballRadius;
        let y = ballRadius;
        let dx = BALL_SPEED;
        let dy = BALL_SPEED;
        let accel = 1;
        const ballColors = [
            "#720000",
            "#960000",
            "#a70000",
            "#ce0000",
            "#ff0000",
        ];
        let colorIndex = 0;

        const paddleWidth = 80;
        const paddleHeight = 10;
        let paddleX = (canvas.width - paddleWidth) / 2;
        let rightPressed = false;
        let leftPressed = false;
        const DELTA_X = 7;

        const brickRowCount = 3;
        const brickColumnCount = 5;
        const brickWidth = 75;
        const brickHeight = 20;
        const brickPadding = 10;
        const brickOffsetTop = 30;
        const brickOffsetLeft = 30;
        const bricks = [];
        let bricksCount = 0;
        const audio = new Audio('beep.mp3');
        const brickColors = [
            '#d26013',
            '#e28033',
            '#f2a053',
        ];

        const drawBall = () => {
            ctx.beginPath();
            ctx.arc(x, y, ballRadius, 0, Math.PI * 2);
            ctx.fillStyle = ballColors[colorIndex];
            ctx.fill();
            ctx.closePath();
        };

        const drawPaddle = () => {
            ctx.beginPath();
            ctx.rect(paddleX, canvas.height-paddleHeight, paddleWidth, paddleHeight);
            ctx.fillStyle = "#0095DD";
            ctx.fill();
            ctx.closePath();
        };

        const drawBricks = () => {
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    if (!bricks[c][r].removed) {
                        let brickX = (c*(brickWidth+brickPadding))+brickOffsetLeft;
                        let brickY = (r*(brickHeight+brickPadding))+brickOffsetTop;
                        bricks[c][r].x = brickX;
                        bricks[c][r].y = brickY;
                        ctx.beginPath();
                        ctx.rect(brickX, brickY, brickWidth, brickHeight);
                        ctx.fillStyle = brickColors[r];
                        ctx.fill();
                        ctx.closePath();
                    }
                }
            }
        }

        const collisionDetection = () => {
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    let b = bricks[c][r];
                    // calculations
                    if (!b.removed) {
                        if (x > b.x && x < b.x + brickWidth && y > b.y && y < b.y + brickHeight) {
                            audio.play();
                            dy = -dy;
                            b.removed = true;
                            bricksCount--;
                            gamePoint += b.point;
                            document.getElementById('point').innerHTML = `POINT ${gamePoint}`;

                            if (bricksCount === 0) {
                                gameOver(true);
                                break;
                            }
                        }
                    }
                }
            }
        }

        const keyDownHandler = (e) => {
            if (e.keyCode === 39) {
                rightPressed = true;
            } else if (e.keyCode === 37) {
                leftPressed = true;
            }
        };

        const keyUpHandler = (e) => {
            if (e.keyCode === 39) {
                rightPressed = false;
            } else if (e.keyCode === 37) {
                leftPressed = false;
            }
        };

        const mouseWheelHandler = (e) => {
            paddleX = Math.min(canvas.width - paddleWidth, Math.max(0, paddleX - e.deltaX));
        };

        const touchHandler = (e) => {
            paddleX = Math.min(canvas.width - paddleWidth, Math.max(0, paddleX - e.deltaX));
        };

        document.addEventListener('keydown', keyDownHandler, false);
        document.addEventListener('keyup', keyUpHandler, false);
        document.addEventListener('wheel', mouseWheelHandler, { passive: true });
        canvas.addEventListener('touchmove', touchHandler, false);

        document.getElementById('level').innerHTML = `LEVEL ${gameLevel}`;
        document.getElementById('point').innerHTML = `POINT ${gamePoint}`;

        const gameStart = () => {
            gameOn = true;
            x = ballRadius;
            y = canvas.height - ballRadius;
            dx = BALL_SPEED * Math.random() * 2;
            dy = -BALL_SPEED;
            gameHandle = setTimeout(draw, 10);

            for (let c = 0; c < brickColumnCount; c++) {
                bricks[c] = [];
                for (let r = 0; r < brickRowCount; r++) {
                    bricks[c][r] = {
                        x: 0, 
                        y: 0, 
                        removed: false, 
                        point: 2 * (brickRowCount - r) - 1,
                        colorIndex: r, 
                    };
                }
            }

            bricksCount = brickColumnCount * brickRowCount;

            document.getElementById('message').innerHTML = `게임 시작: ${bricksCount}`;
            document.getElementById('start').disabled = true;
        };

        const gameOver = (win) => {
            gameOn = false;
            if (gameHandle) {
                // clearInterval(gameHandle);
                clearTimeout(gameHandle);
                gameHandle = null;
            }

            if (win) {
                document.getElementById('message').innerHTML = '게임 승리';
                gameLevel++;
                document.getElementById('level').innerHTML = `LEVEL ${gameLevel}`;
            } else {
                document.getElementById('message').innerHTML = '게임 오버';
            }
            document.getElementById('start').disabled = false;
        };

        const draw = () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // move paddle to right or left
            if (rightPressed && paddleX < canvas.width-paddleWidth) {
                paddleX += DELTA_X;
            } else if (leftPressed && paddleX > 0) {
                paddleX -= DELTA_X;
            }

            // bounce ball on side wall
            if (x + dx < ballRadius || x + dx > canvas.width - ballRadius) {
                dx = -accel * dx;
                dy = accel * dy;
                colorIndex++;
                colorIndex %= ballColors.length;
            }

            // bounce ball on ceiling
            if (y + dy < ballRadius) {
                dx = accel * dx;
                dy = -accel * dy;
                colorIndex++;
                colorIndex %= ballColors.length;
            }

            // bounce ball on paddle
            if (y + dy > canvas.height - ballRadius - paddleHeight && 
                x > paddleX && x < paddleX + paddleWidth) {
                const angle = 6 * ((x - paddleX) / paddleWidth - 0.5);
                console.log('angle', angle);
                dx = accel * Math.abs(dx) * angle;
                dy = -accel * dy;
            }

            // game over if missed
            if (y + dy > canvas.height + ballRadius) {
                gameOver(false);
            }

            // next position of the ball
            x = x + dx;
            y = y + dy;
            
            collisionDetection();
            drawBricks();
            drawPaddle();
            drawBall();

            // animate
            if (gameOn) {
                requestAnimationFrame(draw);
            }
        };
    </script>
</body>
</html>
